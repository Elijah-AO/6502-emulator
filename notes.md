# Golang and emulator notes

## Golang
  - Be careful with bit sizes for ints, and use `int` for general use cases.
  - Convert types to a common type before performing operations.
  - len returns the number of bytes in a string, not the number of characters.
  - Use runes to iterate over characters in a string.
  - Common types for print formatting: %d int, %f float, %s string, %t bool, %v any type.
  - you can use error handling with `if err != nil { return err }` to handle errors.
  - Use `defer` to close resources after a function returns.
  - && and || are short-circuit operators.
  - if statements are in the form `if condition { } else if condition { } else { }`.
  - switch statements are in the form `switch condition { case condition: }`. Use `fallthrough` to go to the next case. No break is needed. These can have a condition (e.g switch foo{}).
  - Initialise and array with `var arr [5]int` or `arr := [...]int{1, 2, 3, 4, 5}`.
  - Slices are like dynamic arrays. They are created with `arr := []int{1, 2, 3, 4, 5}`, or `arr := make([]int, 5, 10)` where 5 is the length and 10 is the capacity. If the capacity is not specified, it is set to the length. Best practice is to declare the capacity.
  - Maps are like dictionaries. They are created with `m := map[string]int{"foo": 1, "bar": 2}`, or `m := make(map[string]int)`. You can delete a key with `delete(m, "foo")`. You can check if a key exists with `val, ok := m["foo"]`. If the key exists, `ok` will be true. A map will return 0 if the key does not exist.
  - For loops are in the form `for i := 0; i < 5; i++ { }`. You can use `for range` to iterate over an array or slice. You can use `for key, value := range m { }` to iterate over a map.
  - When iterating over a string, you get the byte value of the character. To get the character, you can use `fmt.Printf("%c", c)`. You can also cast the string to a slice of runes.: Can use string builders for efficiency.
  - Structs are like classes. They are created with `type Person struct { name string }`. You can create an instance with `p := Person{name: "foo"}`. You can access the field with `p.name`. You can create methods with `func (p *Person) sayHello() { fmt.Println("Hello") }`. You can call the method with `p.sayHello()`.
  - Interfaces are like abstract classes. They are created with `type Animal interface { speak() }`. You can implement the interface with `type Dog struct {}`. You can implement the method with `func (d Dog) speak() { fmt.Println("Woof") }`. You can call the method with `var a Animal = Dog{}`. You can check if a type implements an interface with `_, ok := a.(Dog)`. If the type implements the interface, `ok` will be true.
  - You can use the `reflect` package to get the type of a variable. You can use `reflect.TypeOf(foo)` to get the type of `foo`.
  - Pointers store memory addresses. They are created with `var x *int`. To get the value stored at the pointer you can use `*x` which is called dereferencing the pointer. You can get the memory address of a variable with `&x`. To set the value of a pointer, you can use `*x = 5`. You need to set the value of the pointer before you can use it e.g. `x = &y`.
  - You can use pointers in functions to modify the value of a variable. You can use `func foo(x *int) { *x = 5 }`. You can call the function with `foo(&y)`. This is useful for modifying the value of a variable in a function when you don't want to return the value or care about the original value.
  - Concurrency is different to parallelism. Concurrency is the ability to run multiple tasks at the same time. Parallelism is the ability to run multiple tasks at the same time on different processors. Go uses goroutines for concurrency. 
  - Goroutines are like threads. They are created with `go foo()`. This will run the function concurrently. you can create a wait group to wait for all goroutines to finish with `var wg sync.WaitGroup`. You can add a goroutine to the wait group with `wg.Add(1)` and then decrement the wait group with `wg.Done()`. You can wait for all goroutines to finish with `wg.Wait()`.
  - Use mutexes to prevent deadlock when accessing shared resources. This works by creating and managing locks. You can use read and write locks to allow multiple reads but only one write. You can create a mutex with `var mu sync.Mutex`. You can lock the mutex with `mu.Lock()` and unlock the mutex with `mu.Unlock()`.
  - Channels are used to communicate between goroutines. They are created with `ch := make(chan int)`. You can send a value to a channel with `ch <- 5`. You can receive a value from a channel with `x := <-ch`. You can close a channel with `close(ch)`. You can check if a channel is closed with `x, ok := <-ch`. If the channel is closed, `ok` will be false.
  - You can set the buffer size of a channel with `ch := make(chan int, 5)`. This will allow the channel to store 5 values before blocking.
  - You can use select statements to wait for multiple channels. This is useful for waiting for multiple goroutines to finish. You can use `select { case x := <-ch1: case x := <-ch2: }`. This will wait for a value from either channel.
  - defer statements are executed after a function returns. They are executed in a last in first out order. They are useful for closing resources after a function returns.
  - You can use panic and recover to handle errors. You can use `panic("error")` to throw an error. You can use `recover()` to catch the error. This is useful for handling errors in goroutines.
  - You can use generics to allow for different types e.g. `func foo[T int | string](x T) { }`. This will allow the function to accept an int or a string. You can use the any type to accept any type e.g. `func foo(T any) { }`. 
  - You can use a struct within a struct to create nested structs. This is useful for creating complex data structures. You can access the nested struct with `p := Person{address: Address{city: "London"}}`. You can access the nested struct with `p.address.city`.
